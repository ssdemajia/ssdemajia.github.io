<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>给xv6添加系统调用 | SS</title><link rel="stylesheet" type="text/css" href="../../../../css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="../../../../favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="../../../../favicon.ico"><link rel="apple-touch-icon" href="../../../../apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="../../../../apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="../../../../atom.xml"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-134074056-1','auto');ga('send','pageview');</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><a id="logo" href="../../../../.">SS</a><p class="description">不知道在说些什么</p></div><div id="nav-menu"><a class="current" href="../../../../."><i class="fa undefined"> 首页</i></a><a href="../../../../archives/"><i class="fa undefined"> 归档</i></a><a href="../../../../about/"><i class="fa undefined"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-4"><div class="content_container"><div class="post"><h1 class="post-title">给xv6添加系统调用</h1><div class="post-meta">Sep 18, 2019<span> | </span><span class="category"><a href="../../../../categories/%F0%9F%90%B1%E6%9D%82%E8%B0%88/">🐱杂谈</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 1.9k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-hourglass-half"></i><span class="post-count"> 8</span><span class="post-meta-item-text"> 分钟</span></span></span></div><div class="post-content"><p>这是《Operating System:Three Easy Pieces》的project之一：<a href="https://github.com/remzi-arpacidusseau/ostep-projects/tree/master/initial-xv6">initial-xv6</a>，使用的是MIT对unix v6修改过的x86版本<a href="https://github.com/mit-pdos/xv6-public">xv6</a>。</p>
<h2 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h2><p>汇编指令<strong>int n</strong>调用interrupt procedure（中断处理过程），n的范围是0～255，n作为IDT（interrupt descriptor table）的索引值，前32个中断描述符Intel自己用（主要用于异常），执行int后由用户态变为内核态。</p>
<h3 id="系统调用初始化"><a href="#系统调用初始化" class="headerlink" title="系统调用初始化"></a>系统调用初始化</h3><p>异常分为中断（interrupt）、陷阱（trap）、故障（fault）、终止（abort）。中断主要是来自I&#x2F;O设备的信号结果，中断是异步的，而陷阱（trap）是有意的异常，主要用于实现系统调用，陷阱是同步的。经典的故障是缺页异常</p>
<p>为了在异常发生时能够调用对应的异常处理过程，需要在booting的时候对IDT进行初始化，这个操作是在main.c&#x2F;mainc()&#x2F;tvinit()中进行的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">tvinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++)</span><br><span class="line">    SETGATE(idt[i], <span class="number">0</span>, SEG_KCODE&lt;&lt;<span class="number">3</span>, vectors[i], <span class="number">0</span>);</span><br><span class="line">  SETGATE(idt[T_SYSCALL], <span class="number">1</span>, SEG_KCODE&lt;&lt;<span class="number">3</span>, vectors[T_SYSCALL], DPL_USER);</span><br><span class="line"></span><br><span class="line">  initlock(&amp;tickslock, <span class="string">&quot;time&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SETGATE宏主要用于设置IDT中每个中断描述符，当对应n的中断发生后就会调用的代码</p>
<p>下面是<code>SETGATE</code>宏的代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SETGATE(gate, istrap, sel, off, d)                \</span></span><br><span class="line"><span class="meta">&#123;                                                         \</span></span><br><span class="line"><span class="meta">  (gate).off_15_0 = (uint)(off) &amp; 0xffff;                \</span></span><br><span class="line"><span class="meta">  (gate).cs = (sel);                                      \</span></span><br><span class="line"><span class="meta">  (gate).args = 0;                                        \</span></span><br><span class="line"><span class="meta">  (gate).rsv1 = 0;                                        \</span></span><br><span class="line"><span class="meta">  (gate).type = (istrap) ? STS_TG32 : STS_IG32;           \</span></span><br><span class="line"><span class="meta">  (gate).s = 0;                                           \</span></span><br><span class="line"><span class="meta">  (gate).dpl = (d);                                       \</span></span><br><span class="line"><span class="meta">  (gate).p = 1;                                           \</span></span><br><span class="line"><span class="meta">  (gate).off_31_16 = (uint)(off) &gt;&gt; 16;                  \</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure>

<p>第一个参数是中断描述符，第二个参数是这个描述符类型，参数sel表示代码段选择器，参数off表示在代码段的偏移，参数d表示<code>int n</code>来访问描述符所需要的权限。<code>SETGATE(idt[T_SYSCALL], 1, SEG_KCODE&lt;&lt;3, vectors[T_SYSCALL], DPL_USER);</code>表示T_SYSCALL对应索引中的描述符类型为trap、代码段位SEG_KCODE、offset为vectors[T_SYSCALL]，可以在用户态的时候直接调用，因此这个描述符主要处理系统调用。</p>
<p>下面是描述符结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gatedesc</span> &#123;</span></span><br><span class="line">  uint off_15_0 : <span class="number">16</span>;   <span class="comment">// 段地址低16位</span></span><br><span class="line">  uint cs : <span class="number">16</span>;         <span class="comment">// 代码段选择器</span></span><br><span class="line">  uint args : <span class="number">5</span>;        <span class="comment">// # args, 0 for interrupt/trap gates</span></span><br><span class="line">  uint rsv1 : <span class="number">3</span>;        <span class="comment">// 保留</span></span><br><span class="line">  uint type : <span class="number">4</span>;        <span class="comment">// 类型STS_IG32 32位中断，STS_TG32 32位陷入</span></span><br><span class="line">  uint s : <span class="number">1</span>;           <span class="comment">// must be 0 (system)</span></span><br><span class="line">  uint dpl : <span class="number">2</span>;         <span class="comment">// 可用于内核权限还是用户态权限</span></span><br><span class="line">  uint p : <span class="number">1</span>;           <span class="comment">// 保留字段</span></span><br><span class="line">  uint off_31_16 : <span class="number">16</span>;  <span class="comment">// 段中地址的高16位</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>cs是段选择器，共16位，第0～1位表示权限（0，内核权限；1，用户态），第2位表示指向GDT（0，全局段表）还是LDT（1，局部段表），第3～15位是段表索引。</p>
<p>当中断描述符表设置好后，需要让硬件能够感知，所以汇编指令<code>lidt addr</code>用于加载中断描述符地址到IDTR（interrupt descriptor table registor）这个地址是6字节（32位）其中低16位表示表大小，高32位是 表地址。在main.c&#x2F;main&#x2F;mpmain&#x2F;idtinit中调用。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">idtinit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  lidt(idt, <span class="keyword">sizeof</span>(idt));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是lidt函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">lidt</span><span class="params">(<span class="keyword">struct</span> gatedesc *p, <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">volatile</span> ushort pd[<span class="number">3</span>];</span><br><span class="line">  pd[<span class="number">0</span>] = size<span class="number">-1</span>; <span class="comment">// gate大小</span></span><br><span class="line">  pd[<span class="number">1</span>] = (uint)p;</span><br><span class="line">  pd[<span class="number">2</span>] = (uint)p &gt;&gt; <span class="number">16</span>;</span><br><span class="line">  <span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;lidt (%0)&quot;</span> : : <span class="string">&quot;r&quot;</span> (pd))</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="系统调用执行"><a href="#系统调用执行" class="headerlink" title="系统调用执行"></a>系统调用执行</h3><p>在用户态执行下面的代码调用read系统调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> sz = read(fd, buf, size);</span><br></pre></td></tr></table></figure>

<p>实际上read符号在usys.S文件中定义：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#define SYSCALL(name) \</span><br><span class="line">  .globl name; \</span><br><span class="line">  name: \</span><br><span class="line">    movl $SYS_ ## name, %eax; \</span><br><span class="line">    int $T_SYSCALL; \</span><br><span class="line">    ret</span><br><span class="line"></span><br><span class="line">SYSCALL(read)</span><br></pre></td></tr></table></figure>

<p>SYSCALL是宏定义，<code>SYSCALL(read)</code>展开后相当于下面的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.global read;</span><br><span class="line">read:</span><br><span class="line">	movl $5, %eax;  // SYS_read在syscall.h中定义，等于5</span><br><span class="line">	int $64;</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>

<p>当int指令被调用前，硬件必须保存当前的PC(eip)、eflags、esp等寄存器的值保存到栈上，这些信息被定义为为trapframe结构体（x86.h）因为栈是从高到低顺序，而trapframe是从低到高，所以push的顺序是从trapframe最后一个字段开始的。下面为trapframe结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> &#123;</span></span><br><span class="line">  <span class="comment">// 下面的寄存器由pusha保存到栈上</span></span><br><span class="line">  uint edi;</span><br><span class="line">  uint esi;</span><br><span class="line">  uint ebp;</span><br><span class="line">  uint oesp;      <span class="comment">// useless &amp; ignored</span></span><br><span class="line">  uint ebx;</span><br><span class="line">  uint edx;</span><br><span class="line">  uint ecx;</span><br><span class="line">  uint eax;</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 手动push保存到栈上</span></span><br><span class="line">  ushort gs;</span><br><span class="line">  ushort padding1;</span><br><span class="line">  ushort fs;</span><br><span class="line">  ushort padding2;</span><br><span class="line">  ushort es;</span><br><span class="line">  ushort padding3;</span><br><span class="line">  ushort ds;</span><br><span class="line">  ushort padding4;</span><br><span class="line">  uint trapno;  <span class="comment">// 异常号</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">// 下面由硬件保存到栈上</span></span><br><span class="line">  uint err;</span><br><span class="line">  uint eip;</span><br><span class="line">  ushort cs;</span><br><span class="line">  ushort padding5;</span><br><span class="line">  uint eflags;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// below here only when crossing rings, such as from user to kernel</span></span><br><span class="line">  uint esp;</span><br><span class="line">  ushort ss;</span><br><span class="line">  ushort padding6;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>然后<code>int 64</code>引发的trap，会去IDT中得到中断描述符，根据描述符执行<code>vector64()</code>在vector.S（有vectors.pl脚本生成）中：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.global vector64</span><br><span class="line">vector64:</span><br><span class="line">	pushl $64</span><br><span class="line">	jmp alltraps</span><br></pre></td></tr></table></figure>

<p>这段代码将trap号放入栈中，填充trapframe中trapno这个字段。然后跳转到<code>alltraps</code>（其实所有的异常都会跳到alltraps，默认的异常handle只是将trapno设置）中执行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">.globl alltraps</span><br><span class="line">alltraps:</span><br><span class="line">  # 将trapframe中ds、es、fs、gs保存</span><br><span class="line">  pushl %ds</span><br><span class="line">  pushl %es</span><br><span class="line">  pushl %fs</span><br><span class="line">  pushl %gs</span><br><span class="line">  pushal  # 按照EAX, ECX, EDX, EBX, ESP (original value), EBP, ESI,EDI顺序存到栈上</span><br><span class="line">  </span><br><span class="line">  # Set up data segments.</span><br><span class="line">  movw $(SEG_KDATA&lt;&lt;3), %ax  # 切换为内核代码段，SEG_KDATA为地址，第0到3都为0表示内核权限，使用GDT</span><br><span class="line">  movw %ax, %ds</span><br><span class="line">  movw %ax, %es</span><br><span class="line"></span><br><span class="line">  # Call trap(tf), where tf=%esp</span><br><span class="line">  pushl %esp # 此时esp指向trapframe，作为参数传入trap函数</span><br><span class="line">  call trap</span><br><span class="line">  addl $4, %esp</span><br></pre></td></tr></table></figure>

<p>接下来所有的interrupt&#x2F;trap handle都会进入trap函数，这个函数根据trap号进行选择对应处理函数。下面为trap代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">trap</span><span class="params">(<span class="keyword">struct</span> trapframe *tf)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span>(tf-&gt;trapno == T_SYSCALL)&#123; <span class="comment">// 系统调用</span></span><br><span class="line">    <span class="keyword">if</span>(myproc()-&gt;killed)</span><br><span class="line">      <span class="built_in">exit</span>();</span><br><span class="line">    myproc()-&gt;tf = tf;</span><br><span class="line">    syscall();    <span class="comment">// 执行调用</span></span><br><span class="line">    <span class="keyword">if</span>(myproc()-&gt;killed)</span><br><span class="line">      <span class="built_in">exit</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span>(tf-&gt;trapno)&#123;</span><br><span class="line">  <span class="keyword">case</span> T_IRQ0 + IRQ_TIMER:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> T_IRQ0 + IRQ_IDE:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后进入<code>syscall()</code>函数继续执行，</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">syscall</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> num;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">proc</span> *<span class="title">curproc</span> =</span> myproc();</span><br><span class="line"></span><br><span class="line">  num = curproc-&gt;tf-&gt;eax; <span class="comment">// 之前保存的系统调用号</span></span><br><span class="line">  <span class="keyword">if</span>(num &gt; <span class="number">0</span> &amp;&amp; num &lt; NELEM(syscalls) &amp;&amp; syscalls[num]) &#123;</span><br><span class="line">    curproc-&gt;tf-&gt;eax = syscalls[num]();  <span class="comment">// 执行对应的系统调用</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    cprintf(<span class="string">&quot;%d %s: unknown sys call %d\n&quot;</span>,</span><br><span class="line">            curproc-&gt;pid, curproc-&gt;name, num);</span><br><span class="line">    curproc-&gt;tf-&gt;eax = <span class="number">-1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在syscall中syscalls存放了系统调用实现组成的数组，之后就调用<code>sys_read()</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="title function_">int</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="type">void</span>)</span> = &#123;</span><br><span class="line">...</span><br><span class="line">[SYS_read]    sys_read,</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>返回的值被保存在<code>curproc-&gt;tf&gt;eax</code>中。</p>
<h3 id="执行返回"><a href="#执行返回" class="headerlink" title="执行返回"></a>执行返回</h3><p>当<code>trap()</code>执行完毕后会返回<code>alltrap</code>（trapasm.S）接着向下执行，<code>alltrap</code>下面的代码是<code>trapret</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.globl trapret</span><br><span class="line">trapret:</span><br><span class="line">  popal</span><br><span class="line">  popl %gs</span><br><span class="line">  popl %fs</span><br><span class="line">  popl %es</span><br><span class="line">  popl %ds</span><br><span class="line">  addl $0x8, %esp  # trapno and errcode</span><br><span class="line">  iret</span><br></pre></td></tr></table></figure>

<p>从栈中恢复各个寄存器的值，调用<code>iret</code>返回用户态调用的read函数继续执行。</p>
<h2 id="实现系统调用"><a href="#实现系统调用" class="headerlink" title="实现系统调用"></a>实现系统调用</h2><p>实现<code>getreadcount(void)</code>这个系统调用，返回<code>read()</code>的使用次数。</p>
<p>首先需要在<code>usys.S</code>增加这个系统调用的初步实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SYSCALL(getreadcount)</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 相当于</span></span><br><span class="line">.global getreadcount;</span><br><span class="line">getreadcount:</span><br><span class="line">	movl $SYS_getreadcount, %eax;</span><br><span class="line">	<span class="type">int</span> $T_SYSCALL;</span><br><span class="line">	ret</span><br></pre></td></tr></table></figure>

<p>可以看到需要添加<code>SYS_gettreadcount</code>作为<code>getreadcount()</code>的系统调用号，因此在syscall.h中添加</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SYS_getreadcount  21</span></span><br></pre></td></tr></table></figure>

<p>此时调用会进入IDT表，找到系统调用对应的中断描述符，执行<code>syscall()</code>，因此需要在<code>syscall.c</code>里面增加<code>getreadcount</code>对应的内部实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">sys_getreadcount</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="title function_">int</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="type">void</span>)</span> = &#123;</span><br><span class="line">...</span><br><span class="line">[SYS_read]    sys_read,</span><br><span class="line">...</span><br><span class="line">[SYS_getreadcount]   sys_getreadcount,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>sys_getreadcount</code>也就是我们需要实现的，我这里是增加了一个全局变量<code>readcount</code>，以及用于限制并发的spinlock。在<code>sysproc.c</code>增加定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;spinlock.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">uint readcount;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">readcountlock</span>;</span></span><br></pre></td></tr></table></figure>

<p>在<code>sys_getreadcount</code>的逻辑就是加锁后读取<code>readcount</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sys_getreadcount</span><span class="params">(<span class="type">void</span>)</span> &#123;</span><br><span class="line">  <span class="type">int</span> count;</span><br><span class="line">  acquire(&amp;readcountlock);</span><br><span class="line">  count = readcount;</span><br><span class="line">  release(&amp;readcountlock);</span><br><span class="line">  <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>sys_read()</code>里面增加计数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> uint readcount;</span><br><span class="line"><span class="keyword">extern</span> <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> <span class="title">readcountlock</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">sys_read</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">f</span>;</span></span><br><span class="line">  <span class="type">int</span> n;</span><br><span class="line">  <span class="type">char</span> *p;</span><br><span class="line">  </span><br><span class="line">	acquire(&amp;readcountlock);</span><br><span class="line">  readcount += <span class="number">1</span>;</span><br><span class="line">  release(&amp;readcountlock);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span>(argfd(<span class="number">0</span>, <span class="number">0</span>, &amp;f) &lt; <span class="number">0</span> || argint(<span class="number">2</span>, &amp;n) &lt; <span class="number">0</span> || argptr(<span class="number">1</span>, &amp;p, n) &lt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">  <span class="keyword">return</span> fileread(f, p, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>ss</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="/2019/09/18/给xv6添加系统调用/">https://ssdemajia.github.io/2019/09/18/%E7%BB%99xv6%E6%B7%BB%E5%8A%A0%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本站所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0 CN</a> 许可协议。转载请注明出处！</li></ul></div><br><div class="tags"><a href="../../../../tags/xv6/">xv6</a></div><div class="post-nav"><a class="pre" href="../../../../2020/02/13/afl%E7%99%BD%E7%9A%AE%E4%B9%A6/">翻译 afl白皮书</a><a class="next" href="../../13/x64%E6%B1%87%E7%BC%96%E4%BB%8B%E7%BB%8D/">x64汇编介绍</a></div><div id="comments"><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论（请确保 Disqus 可以正常加载）</button></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://ssdemajia.github.io/2019/09/18/给xv6添加系统调用/';
    this.page.identifier = '2019/09/18/给xv6添加系统调用/';
    this.page.title = '给xv6添加系统调用';
  };</script><script type="text/javascript" id="disqus-lazy-load-script">$.ajax({
url: 'https://disqus.com/next/config.json',
timeout: 2500,
type: 'GET',
success: function(){
  var d = document;
  var s = d.createElement('script');
  s.src = '//dowob.disqus.com/embed.js';
  s.setAttribute('data-timestamp', + new Date());
  (d.head || d.body).appendChild(s);
  $('.disqus_click_btn').css('display', 'none');
},
error: function() {
  $('.disqus_click_btn').css('display', 'block');
}
});</script><script type="text/javascript" id="disqus-click-load">$('.btn_click_load').click(() => {  //click to load comments
    (() => { // DON'T EDIT BELOW THIS LINE
        var d = document;
        var s = d.createElement('script');
        s.src = '//dowob.disqus.com/embed.js';
        s.setAttribute('data-timestamp', + new Date());
        (d.head || d.body).appendChild(s);
    })();
    $('.disqus_click_btn').css('display','none');
});</script><script type="text/javascript" id="disqus-count-script">$(function() {
     var xhr = new XMLHttpRequest();
     xhr.open('GET', '//disqus.com/next/config.json', true);
     xhr.timeout = 2500;
     xhr.onreadystatechange = function () {
       if (xhr.readyState === 4 && xhr.status === 200) {
         $('.post-meta .post-comments-count').show();
         var s = document.createElement('script');
         s.id = 'dsq-count-scr';
         s.src = 'https://dowob.disqus.com/count.js';
         s.async = true;
         (document.head || document.body).appendChild(s);
       }
     };
     xhr.ontimeout = function () { xhr.abort(); };
     xhr.send(null);
   });  </script></div></div></div></div></div><div class="pure-u-1 pure-u-md-4"><div id="footer">Copyright © 2024 <a href="../../../../." rel="nofollow">SS.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/ssdemajia"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/ssdemajia"> SS.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="../../../../js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="../../../../js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="../../../../js/smartresize.js?v=0.0.0"></script></div></body></html>