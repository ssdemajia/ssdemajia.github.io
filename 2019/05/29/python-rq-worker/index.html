<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>python rq worker | SS</title><link rel="stylesheet" type="text/css" href="../../../../css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/normalize/8.0.1/normalize.min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//lib.baomitu.com/pure/1.0.0/grids-responsive-min.css"><link rel="stylesheet" href="//lib.baomitu.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//lib.baomitu.com/jquery/3.3.1/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="../../../../favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="../../../../favicon.ico"><link rel="apple-touch-icon" href="../../../../apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="../../../../apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="../../../../atom.xml"><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
ga('create','UA-134074056-1','auto');ga('send','pageview');</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><a id="logo" href="../../../../.">SS</a><p class="description">不知道在说些什么</p></div><div id="nav-menu"><a class="current" href="../../../../."><i class="fa undefined"> 首页</i></a><a href="../../../../archives/"><i class="fa undefined"> 归档</i></a><a href="../../../../about/"><i class="fa undefined"> 关于</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-4"><div class="content_container"><div class="post"><h1 class="post-title">python rq worker</h1><div class="post-meta">May 29, 2019<span> | </span><span class="category"><a href="../../../../categories/%F0%9F%90%8Dpython/">🐍python</a></span><script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span><span class="post-time"><span class="post-meta-item-text"> | </span><span class="post-meta-item-icon"><i class="fa fa-keyboard-o"></i><span class="post-count"> 2k</span><span class="post-meta-item-text"> 字</span></span></span><span class="post-time"> | <span class="post-meta-item-icon"><i class="fa fa-hourglass-half"></i><span class="post-count"> 9</span><span class="post-meta-item-text"> 分钟</span></span></span></div><div class="post-content"><p>在做项目的时候遇到过一个问题就是同一个worker无法并行的执行多个任务队列的任务，我想看看源码里是什么原因导致出现这个结果。</p>
<h2 id="启动Worker"><a href="#启动Worker" class="headerlink" title="启动Worker"></a>启动Worker</h2><p>需要在命令行内输入<code>rq worker</code></p>
<p>在<code>rq/cli.py</code>的worker函数执行命令行参数解析等操作，关键代码在<code>try…catch</code>中。</p>
<ol>
<li>首先执行<code>cleanup_ghosts</code>，当rq被突然终止时，会没有时间清理注册的worker，这个函数会在开始时清除ttl超时的worker，不然会在worker info里面还显示。</li>
<li>然后将自定义的异常处理导入</li>
<li>创建相连的queue对象</li>
<li>创建worker对象</li>
<li>调用worker的work方法，开始循环执行任务</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">worker</span>(<span class="params">cli_config, burst, logging_level, name, results_ttl,</span></span><br><span class="line"><span class="params">           worker_ttl, job_monitoring_interval, verbose, quiet, sentry_dsn,</span></span><br><span class="line"><span class="params">           exception_handler, pid, queues, log_format, date_format, **options</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;Starts an RQ worker.&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    settings = read_config_file(cli_config.config) <span class="keyword">if</span> cli_config.config <span class="keyword">else</span> &#123;&#125;</span><br><span class="line">    <span class="comment"># Worker specific default arguments</span></span><br><span class="line">    queues = queues <span class="keyword">or</span> settings.get(<span class="string">&#x27;QUEUES&#x27;</span>, [<span class="string">&#x27;default&#x27;</span>])</span><br><span class="line">    name = name <span class="keyword">or</span> settings.get(<span class="string">&#x27;NAME&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> pid:</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(os.path.expanduser(pid), <span class="string">&quot;w&quot;</span>) <span class="keyword">as</span> fp:</span><br><span class="line">            fp.write(<span class="built_in">str</span>(os.getpid()))</span><br><span class="line"></span><br><span class="line">    setup_loghandlers_from_args(verbose, quiet, date_format, log_format)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line"></span><br><span class="line">        cleanup_ghosts(cli_config.connection)</span><br><span class="line">        exception_handlers = []</span><br><span class="line">        <span class="keyword">for</span> h <span class="keyword">in</span> exception_handler:</span><br><span class="line">            exception_handlers.append(import_attribute(h))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> is_suspended(cli_config.connection):</span><br><span class="line">            click.secho(<span class="string">&#x27;RQ is currently suspended, to resume job execution run &quot;rq resume&quot;&#x27;</span>, fg=<span class="string">&#x27;red&#x27;</span>)</span><br><span class="line">            sys.exit(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        queues = [cli_config.queue_class(queue,</span><br><span class="line">                                         connection=cli_config.connection,</span><br><span class="line">                                         job_class=cli_config.job_class)</span><br><span class="line">                  <span class="keyword">for</span> queue <span class="keyword">in</span> queues]</span><br><span class="line">        worker = cli_config.worker_class(queues,</span><br><span class="line">                                         name=name,</span><br><span class="line">                                         connection=cli_config.connection,</span><br><span class="line">                                         default_worker_ttl=worker_ttl,</span><br><span class="line">                                         default_result_ttl=results_ttl,</span><br><span class="line">                                         job_monitoring_interval=job_monitoring_interval,</span><br><span class="line">                                         job_class=cli_config.job_class,</span><br><span class="line">                                         queue_class=cli_config.queue_class,</span><br><span class="line">                                         exception_handlers=exception_handlers <span class="keyword">or</span> <span class="literal">None</span>)</span><br><span class="line"></span><br><span class="line">        worker.work(burst=burst, logging_level=logging_level, date_format=date_format, log_format=log_format)</span><br><span class="line">    <span class="keyword">except</span> ConnectionError <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(e)</span><br><span class="line">        sys.exit(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<h2 id="任务获取"><a href="#任务获取" class="headerlink" title="任务获取"></a>任务获取</h2><p>任务执行的入口是worker.py的work方法。整个worker方法是一个不终止的循环，不断的从队列中取出任务，然后执行。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">work</span>(<span class="params">self, burst=<span class="literal">False</span>, logging_level=<span class="string">&quot;INFO&quot;</span>, date_format=DEFAULT_LOGGING_DATE_FORMAT,</span></span><br><span class="line"><span class="params">         log_format=DEFAULT_LOGGING_FORMAT</span>):</span><br><span class="line">    <span class="variable language_">self</span>._install_signal_handlers()  <span class="comment"># 注册信号处理函数</span></span><br><span class="line">    did_perform_work = <span class="literal">False</span></span><br><span class="line">    <span class="variable language_">self</span>.register_birth()	 <span class="comment"># 向redis注册日期</span></span><br><span class="line">    <span class="variable language_">self</span>.set_state(WorkerStatus.STARTED)</span><br><span class="line">    qnames = <span class="variable language_">self</span>.queue_names()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="variable language_">self</span>.check_for_suspension(burst)</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> <span class="variable language_">self</span>.should_run_maintenance_tasks:</span><br><span class="line">                    <span class="variable language_">self</span>.clean_registries()</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> <span class="variable language_">self</span>._stop_requested:</span><br><span class="line">                    <span class="variable language_">self</span>.log.info(<span class="string">&#x27;Stopping on request&#x27;</span>)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">                timeout = <span class="literal">None</span> <span class="keyword">if</span> burst <span class="keyword">else</span> <span class="built_in">max</span>(<span class="number">1</span>, <span class="variable language_">self</span>.default_worker_ttl - <span class="number">15</span>)</span><br><span class="line"></span><br><span class="line">                result = <span class="variable language_">self</span>.dequeue_job_and_maintain_ttl(timeout)</span><br><span class="line">                <span class="keyword">if</span> result <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">                    <span class="keyword">if</span> burst:</span><br><span class="line">                        <span class="variable language_">self</span>.log.info(<span class="string">&quot;RQ worker %r done, quitting&quot;</span>, <span class="variable language_">self</span>.key)</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">                job, queue = result</span><br><span class="line">                <span class="variable language_">self</span>.execute_job(job, queue)  <span class="comment"># 执行任务</span></span><br><span class="line">                <span class="variable language_">self</span>.heartbeat()</span><br><span class="line"></span><br><span class="line">                did_perform_work = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">except</span> StopRequested:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="variable language_">self</span>.is_horse:</span><br><span class="line">            <span class="variable language_">self</span>.register_death()</span><br><span class="line">    <span class="keyword">return</span> did_perform_work</span><br></pre></td></tr></table></figure>

<ol>
<li><p>首先注册信号处理函数，处理中断进程和终止进程函数。</p>
</li>
<li><p>然后在register_birth()中，将当前worker的key（比如rq:worker:shaoshuaideMacBook-Pro.21131）作为一个hashmap保存，这个hashmap里保存了worker的创建时间、worker的last heart beat、依赖的队列们（默认是default队列名）。最后通过<code>worker_registration.register(self, p)</code>将这个worker的key放入队列所拥有的set中。这样能够快速查到当前队列有哪些worker在使用。</p>
</li>
<li><p>在worker对应的hashmap里添加状态<code>&#123;state: &quot;started&quot;&#125;</code></p>
</li>
<li><p>进入超大<code>while True</code>循环中</p>
<ul>
<li><p>首先<code>check_for_suspension</code>, 判断是否收到暂停命令。暂停标志是保存在redis中key为<code>rq:suspended</code>，如果需要暂停，则在函数<code>check_for_suspension</code>中不断休眠。</p>
</li>
<li><p>从队列中获取一个任务，使用redis <code>BLPOP 队列1 队列2 ... 队列N</code>左边出队一个Job，这里使用<code>BLPOP</code>所以设定了超时时间，同时redis保证了检查顺序，按照队列1-&gt;队列2-&gt;队列3。</p>
</li>
<li><p>将任务交给worker执行，<code>self.execute_job(job, queue)</code></p>
</li>
</ul>
</li>
</ol>
<h2 id="任务执行"><a href="#任务执行" class="headerlink" title="任务执行"></a>任务执行</h2><ol>
<li>首先将任务设置为BUSY，此时worker的状态如下</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; HGETALL rq:worker:shaoshuaideMacBook-Pro.21131</span><br><span class="line">1) &quot;state&quot;</span><br><span class="line">2) &quot;busy&quot;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>调用<code>fork_work_horse(job, queue)</code>，在这个函数中调用<code>os.fork()</code>，因此在windows中<code>python rq</code>是用不了的。</p>
<ul>
<li><p>对于子进程，继续执行<code>self.main_work_horse(job, queue)</code></p>
</li>
<li><p>对于父进程，保存子进程的pid就退出了<code>fork_work_horse</code>了</p>
</li>
</ul>
</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">execute_job</span>(<span class="params">self, job, queue</span>):</span><br><span class="line">    <span class="variable language_">self</span>.set_state(WorkerStatus.BUSY)</span><br><span class="line">    <span class="variable language_">self</span>.fork_work_horse(job, queue)  <span class="comment"># 这里是子进程执行</span></span><br><span class="line">    <span class="variable language_">self</span>.monitor_work_horse(job)  <span class="comment"># 这里是父进程执行</span></span><br><span class="line">    <span class="variable language_">self</span>.set_state(WorkerStatus.IDLE)</span><br></pre></td></tr></table></figure>

<h3 id="子进程执行"><a href="#子进程执行" class="headerlink" title="子进程执行"></a>子进程执行</h3><p>此时子进程进入<code>main_work_horse</code>。</p>
<ol>
<li><p>首先设置忽略SIGINT中断信号（也就是ctrl+c），也就是说当前的work会完成，再退出rq。同时设置SIGTERM信号为默认处理函数（也就是直接退出），即cold shutdown。</p>
</li>
<li><p>在<code>self.perform_job(job, queue)</code>中执行任务。</p>
<ul>
<li>首先更新worker状态：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; HGETALL rq:worker:shaoshuaideMacBook-Pro.21131</span><br><span class="line">1) &quot;state&quot;</span><br><span class="line">2) &quot;busy&quot;</span><br><span class="line">3) &quot;current_job&quot;</span><br><span class="line">4) &quot;8407214b-7cab-4fd4-b409-acfdc5676920&quot;</span><br><span class="line">5) &quot;last_heartbeat&quot;</span><br><span class="line">6) &quot;2019-05-30T07:36:58.802853Z&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li><p>redis的<code>rq:wip:default</code>中保存了当前运行的任务ID。</p>
</li>
<li><p>然后在timeout的时间内运行</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="variable language_">self</span>.death_penalty_class(timeout, JobTimeoutException, job_id=job.<span class="built_in">id</span>):</span><br><span class="line">	rv = job.perform()</span><br></pre></td></tr></table></figure>

<ul>
<li><p>将该任务的ttl去除，然后调用job的<code>self._execute()</code> &#x3D;&gt; 调用<code>self.func</code> ，其中self.func是一个属性装饰器的函数，返回一个需要执行的函数&#x3D;&gt; 调用<code>import_attribute(self.func_name)</code>&#x3D;&gt;导入相关函数后执行<code>(*self.args, **self.kwargs)</code>。</p>
</li>
<li><p>执行结束后在redis中删除对应的依赖job信息，修改worker的一些统计信息，比如将当前的任务对象设为None、将成功的任务数加一、增加任务总执行时间、保存任务执行的信息，下面是当前完成任务的信息。</p>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1:6379&gt; hgetall rq:job:4d73fa5a-562a-4761-a3ca-393c66b2fe49</span><br><span class="line"> 1) &quot;status&quot;</span><br><span class="line"> 2) &quot;started&quot;</span><br><span class="line"> 3) &quot;created_at&quot;</span><br><span class="line"> 4) &quot;2019-05-30T07:51:53.446755Z&quot;</span><br><span class="line"> 5) &quot;data&quot;</span><br><span class="line"> 6) &quot;x\x9ck`\x99*\xce\x00\x01\x1a=&lt;%\xa9\xc5%\xf1E\xa5yz\x05\x05\x05S\xfc4k\xa7\x94L\xd1\x03\x00\x8f\x11\n5&quot;</span><br><span class="line"> 7) &quot;origin&quot;</span><br><span class="line"> 8) &quot;default&quot;</span><br><span class="line"> 9) &quot;description&quot;</span><br><span class="line">10) &quot;test_run.ppp()&quot;</span><br><span class="line">11) &quot;enqueued_at&quot;</span><br><span class="line">12) &quot;2019-05-30T07:51:53.447650Z&quot;</span><br><span class="line">13) &quot;timeout&quot;</span><br><span class="line">14) &quot;180&quot;</span><br><span class="line">15) &quot;started_at&quot;</span><br><span class="line">16) &quot;2019-05-30T07:53:36.856964Z&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>将job放入<code>rq:finished:default</code>中，同时为任务结果设置超时时间。</p>
</li>
<li><p>最后<code>os._exit(0)</code>，子进程完美执行结束。</p>
</li>
</ul>
</li>
</ol>
<h3 id="父进程执行"><a href="#父进程执行" class="headerlink" title="父进程执行"></a>父进程执行</h3><p>父进程在获取子进程pid后，开始执行<code>monitor_work_horse(job)</code>。父进程会调用<code>os.waitpid(self._horse_pid, 0)</code>来等待子进程完成。</p>
<h2 id="处理超时"><a href="#处理超时" class="headerlink" title="处理超时"></a>处理超时</h2><h3 id="worker心跳机制"><a href="#worker心跳机制" class="headerlink" title="worker心跳机制"></a>worker心跳机制</h3><p>对于worker来说，每次获取任务前会调用<code>heartbeat(timeout, pipeline)</code>来更新当前worker这个key的ttl，来防止worker超时。默认的ttl是420秒。同时在<code>prepare_job_execution</code>前也会更新<code>heartbeat()</code>，这个主要是用于dashboard判断这个worker是不是无响应。</p>
<h3 id="job超时处理"><a href="#job超时处理" class="headerlink" title="job超时处理"></a>job超时处理</h3><p>在子进程执行目标任务时（<code>main_work_horse</code>&#x3D;&gt;<code>perform_job</code>&#x3D;&gt;<code>job.perform</code>中），会在前面加上下文管理器</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="variable language_">self</span>.death_penalty_class(timeout, JobTimeoutException, job_id=job.<span class="built_in">id</span>):</span><br><span class="line">	rv = job.perform()</span><br></pre></td></tr></table></figure>

<p><code>self.death_penalty_class</code>vu 为<code>UnixSignalDeathPenalty</code>继承自<code>BaseDeathPenalty</code>，主要是在enter方法中注册针对SIGALRM信号的处理函数，使用<code>signal.alarm（self._timeout)</code>在默认的180秒后发出SIGALRM信号，之后抛出异常。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UnixSignalDeathPenalty</span>(<span class="title class_ inherited__">BaseDeathPenalty</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">handle_death_penalty</span>(<span class="params">self, signum, frame</span>):</span><br><span class="line">        <span class="keyword">raise</span> <span class="variable language_">self</span>._exception(<span class="string">&#x27;Task exceeded maximum timeout value &#x27;</span></span><br><span class="line">                              <span class="string">&#x27;(&#123;0&#125; seconds)&#x27;</span>.<span class="built_in">format</span>(<span class="variable language_">self</span>._timeout))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setup_death_penalty</span>(<span class="params">self</span>):</span><br><span class="line">        signal.signal(signal.SIGALRM, <span class="variable language_">self</span>.handle_death_penalty)</span><br><span class="line">        signal.alarm(<span class="variable language_">self</span>._timeout)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">cancel_death_penalty</span>(<span class="params">self</span>):</span><br><span class="line">        signal.alarm(<span class="number">0</span>)</span><br><span class="line">        signal.signal(signal.SIGALRM, signal.SIG_DFL)</span><br><span class="line">        </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaseDeathPenalty</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, timeout, exception=JobTimeoutException, **kwargs</span>):</span><br><span class="line">        <span class="variable language_">self</span>._timeout = timeout</span><br><span class="line">        <span class="variable language_">self</span>._exception = exception</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__enter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="variable language_">self</span>.setup_death_penalty()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__exit__</span>(<span class="params">self, <span class="built_in">type</span>, value, traceback</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="variable language_">self</span>.cancel_death_penalty()</span><br><span class="line">        <span class="keyword">except</span> BaseTimeoutException:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setup_death_penalty</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">cancel_death_penalty</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError()</span><br></pre></td></tr></table></figure>

<p>如果job运行出现异常将任务设为Failed、从started队列中删除任务、增加任务失败次数、将错误信息输出。</p>
<h2 id="结束worker"><a href="#结束worker" class="headerlink" title="结束worker"></a>结束worker</h2><p>在worker的work方法中使用<code>self._install_signal_handlers()</code>注册了针对SIGINT、SIGTERM的handler self.request_stop。此时收到了一个Ctrl+C，会进入request_stop来处理信号。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">request_stop</span>(<span class="params">self, signum, frame</span>):</span><br><span class="line">    signal.signal(signal.SIGINT, <span class="variable language_">self</span>.request_force_stop)</span><br><span class="line">    signal.signal(signal.SIGTERM, <span class="variable language_">self</span>.request_force_stop)</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">self</span>.handle_warm_shutdown_request()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="variable language_">self</span>.get_state() == WorkerStatus.BUSY:</span><br><span class="line">        <span class="variable language_">self</span>._stop_requested = <span class="literal">True</span></span><br><span class="line">        <span class="variable language_">self</span>.set_shutdown_requested_date()</span><br><span class="line">        <span class="variable language_">self</span>.log.debug(<span class="string">&#x27;Stopping after current horse is finished. &#x27;</span></span><br><span class="line">                       <span class="string">&#x27;Press Ctrl+C again for a cold shutdown.&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">raise</span> StopRequested()</span><br></pre></td></tr></table></figure>

<p>在这个方法中，会重新为SIGINT、SIGTERM绑定新的处理方法self.request_force_stop。</p>
<ol>
<li>如果再次Ctrl+C，会cold shutdown，如果子进程还在运行，会直接kill它。</li>
<li>否则进行warn shutdown，如果子进程还在运行，设置self._stop_reqested，则不会继续从队列获取任务，同时等待子进程运行完毕。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过上面的分析，虽然我指定当前worker从几个queue中获取任务，但是rq的worker只在一个进程中执行，每次只执行一个Job。为了能够并行，对需要并行的任务多开worker。</p>
</div><div><ul class="post-copyright"><li class="post-copyright-author"><strong>本文作者：</strong>ss</li><li class="post-copyright-link"><strong>本文链接：</strong><a href="/2019/05/29/python-rq-worker/">https://ssdemajia.github.io/2019/05/29/python-rq-worker/</a></li><li class="post-copyright-license"><strong>版权声明：</strong>本站所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/cn/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0 CN</a> 许可协议。转载请注明出处！</li></ul></div><br><div class="tags"></div><div class="post-nav"><a class="pre" href="../../../06/05/element-ui-button-border-layout-container-link/">element-ui button layout container input</a><a class="next" href="../../23/redis-pipelining/">redis pipelining</a></div><div id="comments"><div id="disqus_thread"><div class="btn_click_load"><button class="disqus_click_btn">阅读评论（请确保 Disqus 可以正常加载）</button></div><script type="text/javascript">var disqus_config = function () {
    this.page.url = 'https://ssdemajia.github.io/2019/05/29/python-rq-worker/';
    this.page.identifier = '2019/05/29/python-rq-worker/';
    this.page.title = 'python rq worker';
  };</script><script type="text/javascript" id="disqus-lazy-load-script">$.ajax({
url: 'https://disqus.com/next/config.json',
timeout: 2500,
type: 'GET',
success: function(){
  var d = document;
  var s = d.createElement('script');
  s.src = '//dowob.disqus.com/embed.js';
  s.setAttribute('data-timestamp', + new Date());
  (d.head || d.body).appendChild(s);
  $('.disqus_click_btn').css('display', 'none');
},
error: function() {
  $('.disqus_click_btn').css('display', 'block');
}
});</script><script type="text/javascript" id="disqus-click-load">$('.btn_click_load').click(() => {  //click to load comments
    (() => { // DON'T EDIT BELOW THIS LINE
        var d = document;
        var s = d.createElement('script');
        s.src = '//dowob.disqus.com/embed.js';
        s.setAttribute('data-timestamp', + new Date());
        (d.head || d.body).appendChild(s);
    })();
    $('.disqus_click_btn').css('display','none');
});</script><script type="text/javascript" id="disqus-count-script">$(function() {
     var xhr = new XMLHttpRequest();
     xhr.open('GET', '//disqus.com/next/config.json', true);
     xhr.timeout = 2500;
     xhr.onreadystatechange = function () {
       if (xhr.readyState === 4 && xhr.status === 200) {
         $('.post-meta .post-comments-count').show();
         var s = document.createElement('script');
         s.id = 'dsq-count-scr';
         s.src = 'https://dowob.disqus.com/count.js';
         s.async = true;
         (document.head || document.body).appendChild(s);
       }
     };
     xhr.ontimeout = function () { xhr.abort(); };
     xhr.send(null);
   });  </script></div></div></div></div></div><div class="pure-u-1 pure-u-md-4"><div id="footer">Copyright © 2024 <a href="../../../../." rel="nofollow">SS.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/ssdemajia"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/ssdemajia"> SS.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="../../../../js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="../../../../js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="../../../../js/smartresize.js?v=0.0.0"></script></div></body></html>